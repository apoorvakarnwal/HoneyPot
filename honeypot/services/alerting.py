"""
Alerting system for honeypot events.
Supports email notifications, webhook calls, and Slack integration.
"""

import json
import requests
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from collections import defaultdict, deque
import os

# Optional email imports - gracefully handle if not available
try:
    import smtplib
    from email.mime.text import MimeText
    from email.mime.multipart import MimeMultipart
    EMAIL_AVAILABLE = True
except ImportError:
    EMAIL_AVAILABLE = False
    print("[!] Email functionality not available - email alerts will be disabled")

class AlertManager:
    """Manages alert rules, throttling, and notifications"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.alert_history = deque(maxlen=1000)
        self.throttle_counters = defaultdict(int)
        self.last_alert_times = defaultdict(float)
        self.lock = threading.Lock()
        
        # Default thresholds
        self.thresholds = {
            'high_frequency_attacks': 10,  # attacks per minute
            'critical_attack_detected': 1,  # immediate alert
            'new_attacker_country': 1,     # first time seeing country
            'brute_force_threshold': 5,    # failed attempts
            'system_health_critical': 90   # CPU/memory percentage
        }
        
        # Email configuration
        self.email_config = self.config.get('email', {})
        self.smtp_server = self.email_config.get('smtp_server', 'smtp.gmail.com')
        self.smtp_port = self.email_config.get('smtp_port', 587)
        self.sender_email = self.email_config.get('sender_email', '')
        self.sender_password = self.email_config.get('sender_password', '')
        self.recipient_emails = self.email_config.get('recipients', [])
        
        # Webhook configuration
        self.webhook_config = self.config.get('webhooks', {})
        self.webhook_urls = self.webhook_config.get('urls', [])
        
        # Slack configuration (optional)
        self.slack_config = self.config.get('slack', {})
        self.slack_webhook_url = self.slack_config.get('webhook_url', '')
        
        # Alert throttling (prevent spam)
        self.throttle_minutes = self.config.get('throttle_minutes', 5)
    
    def should_alert(self, alert_type: str, key: str = None) -> bool:
        """Check if an alert should be sent based on throttling rules"""
        with self.lock:
            throttle_key = f"{alert_type}:{key}" if key else alert_type
            current_time = time.time()
            last_alert = self.last_alert_times.get(throttle_key, 0)
            
            # Check if enough time has passed since last alert
            if current_time - last_alert < (self.throttle_minutes * 60):
                return False
            
            self.last_alert_times[throttle_key] = current_time
            return True
    
    def send_email_alert(self, subject: str, body: str, priority: str = 'normal'):
        """Send email alert notification"""
        if not EMAIL_AVAILABLE:
            print(f"[!] Email not available, skipping email alert: {subject}")
            return False
            
        if not self.recipient_emails or not self.sender_email:
            print(f"[!] Email configuration incomplete, skipping email alert: {subject}")
            return False
        
        try:
            msg = MimeMultipart()
            msg['From'] = self.sender_email
            msg['To'] = ', '.join(self.recipient_emails)
            msg['Subject'] = f"üçØ Honeypot Alert [{priority.upper()}]: {subject}"
            
            # Add priority headers
            if priority == 'critical':
                msg['X-Priority'] = '1'
                msg['X-MSMail-Priority'] = 'High'
            
            # Create HTML body
            html_body = f"""
            <html>
            <body>
                <h2 style="color: {'#dc3545' if priority == 'critical' else '#ffc107' if priority == 'high' else '#17a2b8'};">
                    üçØ Honeypot Security Alert
                </h2>
                <p><strong>Timestamp:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}</p>
                <p><strong>Priority:</strong> {priority.upper()}</p>
                <div style="background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
                    <pre style="white-space: pre-wrap; margin: 0;">{body}</pre>
                </div>
                <hr>
                <p style="font-size: 12px; color: #6c757d;">
                    This alert was generated by your Honeypot security system.
                </p>
            </body>
            </html>
            """
            
            msg.attach(MimeText(html_body, 'html'))
            
            # Send email
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.sender_email, self.sender_password)
                server.send_message(msg)
            
            print(f"[+] Email alert sent: {subject}")
            return True
            
        except Exception as e:
            print(f"[!] Failed to send email alert: {e}")
            return False
    
    def send_webhook_alert(self, alert_data: Dict[str, Any]):
        """Send webhook notification"""
        if not self.webhook_urls:
            return False
        
        payload = {
            'timestamp': datetime.now().isoformat(),
            'source': 'honeypot',
            'alert': alert_data
        }
        
        success_count = 0
        for webhook_url in self.webhook_urls:
            try:
                response = requests.post(
                    webhook_url,
                    json=payload,
                    timeout=10,
                    headers={'Content-Type': 'application/json'}
                )
                if response.status_code == 200:
                    success_count += 1
                    print(f"[+] Webhook alert sent to {webhook_url}")
                else:
                    print(f"[!] Webhook failed ({response.status_code}): {webhook_url}")
            except Exception as e:
                print(f"[!] Webhook error for {webhook_url}: {e}")
        
        return success_count > 0
    
    def send_slack_alert(self, message: str, priority: str = 'normal'):
        """Send Slack notification"""
        if not self.slack_webhook_url:
            return False
        
        # Choose color based on priority
        color_map = {
            'critical': '#FF0000',
            'high': '#FF6600',
            'medium': '#FFAA00',
            'low': '#00AA00'
        }
        
        payload = {
            'attachments': [{
                'color': color_map.get(priority, '#00AA00'),
                'title': f'üçØ Honeypot Alert [{priority.upper()}]',
                'text': message,
                'footer': 'Honeypot Security System',
                'ts': int(time.time())
            }]
        }
        
        try:
            response = requests.post(self.slack_webhook_url, json=payload, timeout=10)
            if response.status_code == 200:
                print(f"[+] Slack alert sent")
                return True
            else:
                print(f"[!] Slack alert failed ({response.status_code})")
        except Exception as e:
            print(f"[!] Slack alert error: {e}")
        
        return False
    
    def trigger_alert(self, alert_type: str, title: str, message: str, 
                     priority: str = 'medium', metadata: Dict[str, Any] = None):
        """Trigger an alert through all configured channels"""
        
        # Check throttling
        if not self.should_alert(alert_type, title):
            print(f"[~] Alert throttled: {alert_type} - {title}")
            return
        
        print(f"[!] ALERT [{priority.upper()}]: {title}")
        
        # Record alert
        alert_record = {
            'timestamp': datetime.now().isoformat(),
            'type': alert_type,
            'title': title,
            'message': message,
            'priority': priority,
            'metadata': metadata or {}
        }
        
        with self.lock:
            self.alert_history.append(alert_record)
        
        # Send through all channels (in separate threads to avoid blocking)
        if self.recipient_emails:
            threading.Thread(
                target=self.send_email_alert,
                args=(title, message, priority),
                daemon=True
            ).start()
        
        if self.webhook_urls:
            threading.Thread(
                target=self.send_webhook_alert,
                args=(alert_record,),
                daemon=True
            ).start()
        
        # Only send Slack alerts if webhook URL is configured
        if self.slack_webhook_url and self.slack_webhook_url.strip():
            threading.Thread(
                target=self.send_slack_alert,
                args=(f"{title}\n\n{message}", priority),
                daemon=True
            ).start()
    
    def check_attack_patterns(self, event_data: Dict[str, Any]):
        """Analyze event for alert-worthy patterns"""
        
        # Critical attack types that warrant immediate alerts
        critical_attacks = ['command_injection', 'sql_injection', 'lfi_attempt']
        attack_indicators = event_data.get('attack_indicators', [])
        
        if any(attack in critical_attacks for attack in attack_indicators):
            self.trigger_alert(
                'critical_attack_detected',
                f'Critical Attack Detected: {", ".join(attack_indicators)}',
                f"""
Critical security event detected:

Source IP: {event_data.get('peer', 'Unknown')}
Service: {event_data.get('service', 'Unknown')}
Attack Types: {', '.join(attack_indicators)}
Method: {event_data.get('method', 'N/A')}
Path: {event_data.get('path', 'N/A')}
User Agent: {event_data.get('headers', {}).get('User-Agent', 'N/A')}

Raw Event Data:
{json.dumps(event_data, indent=2)}
                """.strip(),
                priority='critical',
                metadata={'source_ip': event_data.get('peer'), 'attack_types': attack_indicators}
            )
        
        # High-frequency attack detection
        source_ip = event_data.get('peer')
        if source_ip and attack_indicators:
            with self.lock:
                self.throttle_counters[f"attacks_from_{source_ip}"] += 1
                
                # Alert if too many attacks from same IP
                if self.throttle_counters[f"attacks_from_{source_ip}"] >= self.thresholds['high_frequency_attacks']:
                    self.trigger_alert(
                        'high_frequency_attacks',
                        f'High-Frequency Attacks from {source_ip}',
                        f"""
Detected high-frequency attacks from {source_ip}:

Attack Count: {self.throttle_counters[f"attacks_from_{source_ip}"]}
Recent Attack Types: {', '.join(attack_indicators)}
Service: {event_data.get('service', 'Unknown')}

This IP may be conducting an automated attack campaign.
                        """.strip(),
                        priority='high',
                        metadata={'source_ip': source_ip, 'attack_count': self.throttle_counters[f"attacks_from_{source_ip}"]}
                    )
                    
                    # Reset counter after alert
                    self.throttle_counters[f"attacks_from_{source_ip}"] = 0
    
    def check_system_health(self, metrics: Dict[str, Any]):
        """Check system metrics for alert conditions"""
        system_health = metrics.get('system_health', {})
        
        cpu_percent = system_health.get('cpu_percent', 0)
        memory_percent = system_health.get('memory_percent', 0)
        
        if cpu_percent >= self.thresholds['system_health_critical']:
            self.trigger_alert(
                'system_health_critical',
                f'Critical CPU Usage: {cpu_percent:.1f}%',
                f"""
System resources are critically high:

CPU Usage: {cpu_percent:.1f}%
Memory Usage: {memory_percent:.1f}%
Uptime: {system_health.get('uptime_hours', 0):.1f} hours

This may indicate a DoS attack or system overload.
                """.strip(),
                priority='critical'
            )
        
        if memory_percent >= self.thresholds['system_health_critical']:
            self.trigger_alert(
                'system_health_critical',
                f'Critical Memory Usage: {memory_percent:.1f}%',
                f"""
Memory usage is critically high:

Memory Usage: {memory_percent:.1f}%
CPU Usage: {cpu_percent:.1f}%

This may indicate a memory exhaustion attack.
                """.strip(),
                priority='high'
            )
    
    def get_alert_history(self, hours: int = 24) -> List[Dict[str, Any]]:
        """Get recent alert history"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        
        with self.lock:
            return [
                alert for alert in self.alert_history
                if datetime.fromisoformat(alert['timestamp']) >= cutoff_time
            ]

# Global alert manager instance
alert_manager = None

def initialize_alerting(config: Dict[str, Any] = None):
    """Initialize the global alert manager"""
    global alert_manager
    
    # Load configuration from environment if not provided
    if not config:
        config = {
            'email': {
                'smtp_server': os.getenv('SMTP_SERVER', 'smtp.gmail.com'),
                'smtp_port': int(os.getenv('SMTP_PORT', '587')),
                'sender_email': os.getenv('ALERT_SENDER_EMAIL', ''),
                'sender_password': os.getenv('ALERT_SENDER_PASSWORD', ''),
                'recipients': os.getenv('ALERT_RECIPIENTS', '').split(',') if os.getenv('ALERT_RECIPIENTS') else []
            },
            'webhooks': {
                'urls': os.getenv('WEBHOOK_URLS', '').split(',') if os.getenv('WEBHOOK_URLS') else []
            },
            'slack': {
                'webhook_url': os.getenv('SLACK_WEBHOOK_URL', '')
            },
            'throttle_minutes': int(os.getenv('ALERT_THROTTLE_MINUTES', '5'))
        }
    
    alert_manager = AlertManager(config)
    print("[+] Alerting system initialized")

def send_alert(alert_type: str, title: str, message: str, priority: str = 'medium'):
    """Convenience function to send alerts"""
    if alert_manager:
        alert_manager.trigger_alert(alert_type, title, message, priority)
    else:
        print(f"[!] Alert manager not initialized: {title}")

def check_event_for_alerts(event_data: Dict[str, Any]):
    """Check if an event should trigger alerts"""
    if alert_manager:
        alert_manager.check_attack_patterns(event_data)

def check_metrics_for_alerts(metrics: Dict[str, Any]):
    """Check if metrics should trigger alerts"""
    if alert_manager:
        alert_manager.check_system_health(metrics)
